 - - Intro
Used chatgpt for easier explanation.
Use ctrl + f and search for the specific function.

// int dupstring_compare(const char str1, const char str2) - - - - - - 
This program is a function named dupstring_compare that compares two strings, str1 and str2, character by character. It takes two arguments, both of which are pointers to constant character arrays, const char *str1 and const char *str2.

The function begins by initializing two integer variables, i and j, to 0. These variables will be used to iterate over the strings str1 and str2.

The function then checks if the first character of str1 is a '+'. If it is, and the first character of str2 is not a '+', i is incremented. If the first character of str2 is a '+' and the first character of str1 is not a '+', i is also incremented. This comparison of the first characters is done to handle a special case where the two strings may have different leading characters, but are otherwise identical.

After the initial character comparison, the function enters a loop that will continue as long as there are characters in both str1 and str2, and as long as the characters being compared are identical. Within the loop, the function increments both i and j, moving to the next character in each string.

Once the loop has exited, the function returns the difference between the ASCII values of the next character in str1 and str2, cast to an unsigned character. This difference will be zero if the two strings are identical, negative if str1 comes before str2 in alphabetical order, and positive if str1 comes after str2.
----
// bool	check_duplicates(char *argv[]) - - - - - - - - - - - - - - - - -
This program is a function named check_duplicates that takes an array of strings argv[] as an argument and checks for any duplicates in the array.

The function begins by initializing two integer variables, i and j, to 1. The reason for starting at 1 is that the first element of argv[] is typically the name of the program itself, which is not relevant for checking duplicates.

The function then enters a loop that will continue as long as there are elements in argv[]. Within this loop, the function initializes j to 1 and enters another loop that will continue as long as there are elements in argv[].

Within the inner loop, the function first checks if j is equal to i. If it is, the function does not compare the strings at argv[i] and argv[j], as they are the same element of the array.

If j is not equal to i, the function calls the dupstring_compare function to compare the strings at argv[i] and argv[j]. If the two strings are identical, dupstring_compare returns 0 and the function immediately returns true, indicating that a duplicate has been found.

After the inner loop has exited, the function increments i and begins another iteration of the outer loop. This process continues until all elements of argv[] have been compared.

If the function completes without finding any duplicates, it returns false.

---
In this example, the main function checks that the program has been passed at least two arguments (argc < 3). If there are not enough arguments, it prints a usage message and returns 1.

If there are enough arguments, the check_duplicates function is called with argv as an argument. If check_duplicates returns true, indicating that there are duplicate values in argv, the program prints "Duplicate values found!". Otherwise, the program prints "No duplicates found.".

// int	find_zeros(char *argv)
// bool	check_number(char *argv)
check_number, takes a single string argument argv and checks whether it contains only a number. It starts by initializing an integer variable i to 0.

The function then checks if the first character of the input string argv is either a plus sign (+) or a minus sign (-) and if the next character after the sign is not the end of the string (\0). If this condition is true, it increments i to skip over the sign and continue to the rest of the input string.

The function then enters a loop that continues as long as there are characters left in the input string. Within the loop, it checks if the current character is a digit between 0 and 9 inclusive. If the character is a digit, it increments i to move to the next character. If the character is not a digit, the function returns false, indicating that the input is not a number.

If the function completes the loop without returning false, it means that all characters in the input string are digits, and it returns true, indicating that the input is a number.

---
// bool check_input(char *argv[])
The function check_input takes an array of strings argv as input and returns a boolean value. The purpose of this function is to check the input values in the array argv to ensure that they meet certain conditions.

The function starts by initializing variables i and zeros to 1 and 0 respectively. It then enters a loop that checks each element of the argv array. If any element is not a number, the function immediately returns false.

If all elements of the argv array are numbers, the function checks for duplicates using the check_duplicates function. If there are any duplicates, the function returns false.

The function also counts the number of occurrences of 0 in the input values using the find_zeros function. If there are more than one occurrence of 0, the function also returns false.

Finally, if all input values meet the conditions and there are no duplicates, the function returns true.

---
//void  assign_rank(t_stack *stack_a, int stack_size)
So, the assign_rank function is used to assign a rank to each value in the stack_a stack. This rank can be used to easily order and compare the values in the stack without having to directly compare the values themselves, which can be useful in certain sorting algorithms.

Here's how the function works:

The function takes in two arguments: a pointer to the stack_a stack, and the size of the stack.

The function then enters a loop that will run stack_size - 1 times. This is because the highest value in the stack will be assigned a rank of stack_size, and the lowest value will be assigned an rank of 1.

Inside the loop, the function initializes a few variables: a pointer ptr to the stack_a stack, an integer value to hold the current highest value found, and a pointer highest to hold the node with the current highest value found.

The function then enters another loop that will iterate through each node in the stack_a stack. If a node's value is equal to INT_MIN (the lowest possible integer value in C) and its rank is 0 (which means it hasn't been assigned an rank yet), then its rank is set to 1. This is because INT_MIN will be assigned a rank of 1 since it's the lowest possible value in the stack.

If a node's value is greater than the current value variable and its rank is 0, then the value variable is updated to the node's value, the highest pointer is updated to point to the current node, and the ptr pointer is reset to point back to the beginning of the stack_a stack. This is because we want to find the highest value in the stack that hasn't already been assigned a rank.

If a node's value is less than or equal to the current value variable, or if the node has already been assigned a rank, then the ptr pointer is simply moved to the next node in the stack.

Once the inner loop has finished iterating through all the nodes in the stack, the highest node (which should contain the current highest value in the stack) is assigned a rank of stack_size. This is because we're assigning ranks from highest (stack_size) to lowest (1).

The outer loop then repeats until all nodes in the stack have been assigned a rank.